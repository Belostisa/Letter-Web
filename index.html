<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Encrypted Letter</title>
  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

  <!-- FULL BACKGROUND VIDEO -->
  <div class="bg-video">
    <video autoplay muted loop playsinline>
      <source src="media/bg.mp4" type="video/mp4">
    </video>
  </div>

  <!-- AUDIO (loop is fine; we will handle end/stop too) -->
  <audio id="bgAudio" loop preload="auto" crossorigin="anonymous">
    <source src="media/sextape.mp3" type="audio/mpeg">
  </audio>

  <!-- FLOWERS -->
  <section class="flowers-section">
    <video autoplay muted loop playsinline class="flowers-video">
      <source src="media/flowers2.mp4" type="video/mp4">
    </video>
  </section>

  <!-- WAVE OVERLAY -->
  <div class="wave-overlay" id="waveOverlay" aria-hidden="true">
    <canvas id="waveCanvas"></canvas>
  </div>

  <!-- SINGLE PLAY BUTTON -->
  <button class="wave-play" id="playWave" aria-label="Play">▶</button>

  <!-- ENVELOPE -->
  <section class="envelope-section">
    <div class="envelope" onclick="openEmail()">
      <div class="envelope-back"></div>
      <div class="inbox-label">INBOX</div>
      <div class="envelope-flap"></div>
    </div>
  </section>

  <!-- EMAIL WINDOW -->
  <div class="email-overlay" id="emailOverlay">
    <div class="email-window">
      <div class="email-header">
        <span class="email-title">Inbox</span>
        <button class="email-close" onclick="closeEmail()">✕</button>
      </div>

      <div class="email-body" id="emailContent"></div>

      <div class="email-footer">
        <button onclick="prevPage()">◀ Prev</button>
        <span id="pageIndicator">1 / 3</span>
        <button onclick="nextPage()">Next ▶</button>
      </div>
    </div>
  </div>

<script>
/* ============================================================
   PERFORMANCE PATCHES INCLUDED
   ✅ Cap DPR for canvases (huge mobile win)
   ✅ FX loop sleeps when no particles (no constant 60fps clears)
   ✅ MAX_PARTICLES cap + click spam control (fixes lag on flower spam)
   ✅ Smaller analyser FFT + fewer wave points
   ✅ Stop waves + show play button when audio ends / pauses
   ✅ Keeps typewriter + cache + autoscroll + envelope delay
============================================================ */

/* =========================
   EMAIL PAGES
========================= */
const pages = [
`Вы помните,
Вы всё, конечно, помните,
Как я стоял,
Приблизившись к стене,
Взволнованно ходили вы по комнате
И что-то резкое
В лицо бросали мне.

Вы говорили:
Нам пора расстаться,
Что вас измучила
Моя шальная жизнь,
Что вам пора за дело приниматься,
А мой удел —
Катиться дальше, вниз.
`,
`Но вы не знали,
Что в сплошном дыму,
В развороченном бурей быте
С того и мучаюсь,
Что не пойму,
Куда несет нас рок событий…

Любимая!
Сказать приятно мне:
Я избежал паденья с кручи.
Теперь в Пиндосской стороне
Я самый яростный попутчик.
`,
`Простите мне…
Я знаю: вы не та —
Живете вы
С серьезным, умным мужем;
Что не нужна вам наша маета,
И сам я вам
Ни капельки не нужен.

Живите так,
Как вас ведет звезда,
Ебите баб на свежем сене.
С приветствием,
Вас помнящий всегда
Знакомый ваш
Сергей Есенин.`
];

let currentPage = 0;

/* =========================
   TYPEWRITER REVEAL
========================= */
const emailBody = document.getElementById("emailContent");
let typingTimer = 0;
let typingToken = 0;
const typedCache = new Map();

// cursor CSS once
(function addCursorCSS(){
  if (document.getElementById("twCursorCSS")) return;
  const s = document.createElement("style");
  s.id = "twCursorCSS";
  s.textContent = `
    .tw-cursor{
      display:inline-block;
      width:0.7ch;
      margin-left:0.15ch;
      color:#9AFF7A;
      opacity:1;
      animation: twBlink 1.05s steps(1,end) infinite;
    }
    @keyframes twBlink { 0%,49%{opacity:1} 50%,100%{opacity:0} }
  `;
  document.head.appendChild(s);
})();

function stopTyping(){
  typingToken++;
  clearTimeout(typingTimer);
}

function autoScrollToCursor(){
  emailBody.scrollTop = emailBody.scrollHeight;
}

function getDelayForChar(ch, prevCh){
  let d = 52;
  if (ch === " ") d = 18;
  if (ch === ",") d = 170;
  if (ch === "." || ch === "!" || ch === "?") d = 340;
  if (prevCh === "\n" && ch === "\n") d = 1050;
  if (ch === "\n") d = 140;
  d += Math.random() * 22;
  return d;
}

function typewriterPage(pageIndex){
  stopTyping();
  const myToken = ++typingToken;

  const fullText = pages[pageIndex];
  const cached = typedCache.get(pageIndex);

  if (cached?.done){
    emailBody.textContent = fullText;
    document.getElementById("pageIndicator").textContent = `${pageIndex + 1} / ${pages.length}`;
    emailBody.scrollTop = 0;
    return;
  }

  let i = cached?.i ?? 0;
  let typedText = cached?.text ?? "";

  emailBody.textContent = typedText;

  const cursor = document.createElement("span");
  cursor.className = "tw-cursor";
  cursor.textContent = "▋";
  emailBody.appendChild(cursor);

  document.getElementById("pageIndicator").textContent = `${pageIndex + 1} / ${pages.length}`;
  emailBody.scrollTop = 0;

  let last = (typedText.length ? typedText[typedText.length - 1] : "");

  const step = () => {
    if (myToken !== typingToken) return;

    if (i >= fullText.length){
      typedCache.set(pageIndex, { i: fullText.length, text: fullText, done: true });
      typingTimer = setTimeout(() => {
        if (cursor.parentNode) cursor.remove();
        autoScrollToCursor();
      }, 250);
      return;
    }

    const burst = (Math.random() < 0.08) ? 2 : 1;
    let chunk = "";

    for (let k = 0; k < burst && i < fullText.length; k++){
      const ch = fullText[i];
      cursor.insertAdjacentText("beforebegin", ch);
      chunk += ch;
      last = ch;
      i++;
    }

    typedText += chunk;
    typedCache.set(pageIndex, { i, text: typedText, done: false });

    autoScrollToCursor();

    const nextCh = fullText[i] || "";
    const delay = getDelayForChar(nextCh, last);
    typingTimer = setTimeout(step, delay);
  };

  step();
}

function renderPage(){ typewriterPage(currentPage); }

function openEmail(){
  const env = document.querySelector(".envelope");
  const overlayEl = document.getElementById("emailOverlay");

  env.classList.add("open");

  const DURATION_MS = 900;
  if (openEmail._pending) return;
  openEmail._pending = true;

  setTimeout(() => {
    openEmail._pending = false;
    overlayEl.style.display = "flex";
    renderPage();
  }, DURATION_MS + 60);
}

function closeEmail(){
  stopTyping();
  document.querySelector(".envelope").classList.remove("open");
  document.getElementById("emailOverlay").style.display = "none";
}

function nextPage(){
  if (currentPage < pages.length - 1){ currentPage++; renderPage(); }
}
function prevPage(){
  if (currentPage > 0){ currentPage--; renderPage(); }
}

/* =========================
   WAVES + PARTICLES
========================= */
const playBtn = document.getElementById("playWave");
const audioEl = document.getElementById("bgAudio");
const overlay = document.getElementById("waveOverlay");
const waveCanvas  = document.getElementById("waveCanvas");
const waveCtx     = waveCanvas.getContext("2d", { alpha: true });

const flowersSection = document.querySelector(".flowers-section");
const flowersVideo   = document.querySelector(".flowers-video");
const envelopeEl     = document.querySelector(".envelope");

let audioCtx = null;
let analyser = null;
let srcNode  = null;
let timeData = null;
let freqData = null;

let started = false;
let rafId = 0;
let posRaf = 0;

const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
const lerp  = (a, b, t) => a + (b - a) * t;

function waveThickness(){
  return window.matchMedia("(max-width: 600px)").matches ? 1.0 : 1.25;
}

/* =========================
   DPR CAP (BIG PERF WIN)
========================= */
function getDPR(){
  const isMobile = window.matchMedia("(max-width: 600px)").matches;
  return Math.min(isMobile ? 1.2 : 1.5, window.devicePixelRatio || 1);
}

/* =========================
   FULLSCREEN FX CANVAS
========================= */
const fxCanvas = document.createElement("canvas");
fxCanvas.id = "fxCanvas";
Object.assign(fxCanvas.style, {
  position: "fixed",
  inset: "0",
  width: "100vw",
  height: "100vh",
  zIndex: "5",
  pointerEvents: "none"
});
document.body.appendChild(fxCanvas);

const fxCtx = fxCanvas.getContext("2d", { alpha: true });

function resizeFxCanvas(){
  const dpr = getDPR();
  fxCanvas.width = Math.floor(innerWidth * dpr);
  fxCanvas.height = Math.floor(innerHeight * dpr);
  fxCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function resizeWaveCanvas(){
  const rect = waveCanvas.getBoundingClientRect();
  const dpr = getDPR();
  const w = Math.max(1, Math.floor(rect.width  * dpr));
  const h = Math.max(1, Math.floor(rect.height * dpr));
  if (waveCanvas.width !== w || waveCanvas.height !== h){
    waveCanvas.width = w;
    waveCanvas.height = h;
  }
  waveCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

/* =========================
   Place waves BETWEEN flowers + envelope
========================= */
function updateWavePosition(){
  if (!flowersSection || !envelopeEl) return;

  const f = flowersSection.getBoundingClientRect();
  const e = envelopeEl.getBoundingClientRect();

  let y = (f.bottom + e.top) / 2;
  y -= Math.min(28, innerHeight * 0.035);

  const overlayH = overlay?.getBoundingClientRect().height || 120;
  y -= overlayH / 2;

  const pad = Math.max(48, Math.min(96, innerHeight * 0.08));
  y = clamp(y, pad, innerHeight - pad);

  document.documentElement.style.setProperty("--wave-y", `${y}px`);
}

function scheduleLayoutUpdate(){
  if (posRaf) return;
  posRaf = requestAnimationFrame(() => {
    posRaf = 0;
    updateWavePosition();
    resizeWaveCanvas();
    resizeFxCanvas();
  });
}

window.addEventListener("resize", scheduleLayoutUpdate, { passive: true });
window.addEventListener("scroll", scheduleLayoutUpdate, { passive: true });

if (window.visualViewport){
  visualViewport.addEventListener("resize", scheduleLayoutUpdate, { passive: true });
  visualViewport.addEventListener("scroll", scheduleLayoutUpdate, { passive: true });
}

const ro = new ResizeObserver(() => scheduleLayoutUpdate());
if (flowersSection) ro.observe(flowersSection);
if (envelopeEl) ro.observe(envelopeEl);

scheduleLayoutUpdate();
setTimeout(scheduleLayoutUpdate, 150);
setTimeout(scheduleLayoutUpdate, 650);

/* =========================
   Audio analyser (lighter)
========================= */
function setupAnalyser(){
  if (audioCtx) return;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  analyser.smoothingTimeConstant = 0.82;

  timeData = new Uint8Array(analyser.frequencyBinCount);
  freqData = new Uint8Array(analyser.frequencyBinCount);

  srcNode = audioCtx.createMediaElementSource(audioEl);
  srcNode.connect(analyser);
  analyser.connect(audioCtx.destination);
}

let rmsSmooth = 0;
let trebleSmooth = 0;

function readAudio(){
  analyser.getByteTimeDomainData(timeData);
  analyser.getByteFrequencyData(freqData);

  let sum = 0;
  for (let i = 0; i < timeData.length; i++){
    const v = (timeData[i] - 128) / 128;
    sum += v * v;
  }
  const rms = Math.sqrt(sum / timeData.length);
  rmsSmooth = lerp(rmsSmooth, rms, 0.09);

  let hi = 0;
  const start = Math.floor(freqData.length * 0.35);
  for (let i = start; i < freqData.length; i++) hi += freqData[i];
  const hiNorm = hi / ((freqData.length - start) * 255);
  trebleSmooth = lerp(trebleSmooth, clamp(hiNorm, 0, 1), 0.12);

  return { level: rmsSmooth, treble: trebleSmooth };
}

/* =========================
   Particles (FX loop sleeps + spam protection)
========================= */
const particles = [];
const MAX_PARTICLES = 220; // ✅ hard cap (try 160–260)

function rand(a, b){ return a + Math.random() * (b - a); }

let fxRaf = 0;
function ensureFxLoop(){
  if (fxRaf) return;
  const tick = () => {
    if (particles.length === 0){
      fxRaf = 0;
      return;
    }
    drawParticles();
    fxRaf = requestAnimationFrame(tick);
  };
  fxRaf = requestAnimationFrame(tick);
}

function clampParticles(){
  while (particles.length > MAX_PARTICLES) particles.shift();
}

function spawnFlowerOrbs(vx, vy){
  const isMobile = window.matchMedia("(max-width: 600px)").matches;
  const count = isMobile ? 8 : 14; // ✅ fewer on mobile

  for (let i = 0; i < count; i++){
    const angle = rand(-Math.PI * 0.80, -Math.PI * 0.20);
    const speed = rand(0.9, 2.4);
    particles.push({
      x: vx, y: vy,
      vx: Math.cos(angle) * speed + rand(-0.22, 0.22),
      vy: Math.sin(angle) * speed + rand(-0.16, 0.10),
      life: 1,
      r: rand(0.9, 1.7),
      w: rand(1.3, 2.6),
      ph: rand(0, Math.PI * 2),
      type: "orb"
    });
  }

  clampParticles();
  ensureFxLoop();
}

function spawnCyanBurst(vx, vy){
  const isMobile = window.matchMedia("(max-width: 600px)").matches;
  const count = isMobile ? 8 : 12;

  for (let i = 0; i < count; i++){
    const angle = rand(0, Math.PI * 2);
    const speed = rand(0.7, 1.8);
    particles.push({
      x: vx, y: vy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      r: rand(1.6, 3.0),
      type: "cyan"
    });
  }

  clampParticles();
  ensureFxLoop();
}

function drawParticles(){
  if (particles.length === 0) return;

  fxCtx.clearRect(0, 0, innerWidth, innerHeight);

  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];

    p.x += p.vx;
    p.y += p.vy;

    p.vx *= 0.989;
    p.vy *= 0.988;
    p.vy -= (p.type === "orb" ? 0.0062 : 0.0028);

    if (p.type === "orb"){
      const t = performance.now() * 0.001;
      p.x += Math.sin(t * p.w + p.ph) * 0.26;
    }

    // ✅ slightly shorter lifetime reduces “pile-up”
    p.life -= (p.type === "orb" ? 0.012 : 0.016);

    if (p.life <= 0){
      particles.splice(i, 1);
      continue;
    }

    fxCtx.save();
    fxCtx.globalCompositeOperation = "lighter";
    fxCtx.globalAlpha = p.life;

    if (p.type === "cyan"){
      fxCtx.fillStyle = "rgba(120,255,255,0.66)";
      fxCtx.shadowColor = "rgba(120,255,255,0.30)";
      fxCtx.shadowBlur = 10;
      fxCtx.beginPath();
      fxCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      fxCtx.fill();
      fxCtx.restore();
      continue;
    }

    const core = p.r;
    const aura = p.r * 6.3;

    fxCtx.fillStyle = "rgba(255,140,210,0.10)";
    fxCtx.shadowColor = "rgba(255,140,210,0.22)";
    fxCtx.shadowBlur = 18;
    fxCtx.beginPath();
    fxCtx.arc(p.x, p.y, aura, 0, Math.PI * 2);
    fxCtx.fill();

    fxCtx.shadowBlur = 12;
    fxCtx.fillStyle = "rgba(255,195,235,0.42)";
    fxCtx.beginPath();
    fxCtx.arc(p.x, p.y, core, 0, Math.PI * 2);
    fxCtx.fill();

    fxCtx.restore();
  }
}

/* =========================
   FLOWER CLICK -> ORBS
   ✅ dynamic cooldown when lots of particles exist
========================= */
let lastFlower = 0;

function pointInShrunkRect(x, y, r, shrinkX = 0.18, shrinkTop = 0.10, shrinkBottom = 0.22){
  const left   = r.left + r.width  * shrinkX;
  const right  = r.right - r.width * shrinkX;
  const top    = r.top + r.height  * shrinkTop;
  const bottom = r.bottom - r.height * shrinkBottom;
  return (x >= left && x <= right && y >= top && y <= bottom);
}

document.addEventListener("click", (e) => {
  if (!flowersVideo) return;
  if (e.target.closest(".envelope") || e.target.closest(".email-overlay")) return;

  const r = flowersVideo.getBoundingClientRect();
  const inside = pointInShrunkRect(e.clientX, e.clientY, r, 0.28, 0.16, 0.44);
  if (!inside) return;

  const now = Date.now();

  const extraDelay = particles.length > 140 ? 220 : 0;
  const minGap = 140 + extraDelay;

  if (now - lastFlower < minGap) return;
  lastFlower = now;

  spawnFlowerOrbs(e.clientX, e.clientY);
}, { passive: true });

/* =========================
   Play button show/hide logic
========================= */
function showPlayButton(){ playBtn.classList.remove("hidden"); }
function hidePlayButton(){ playBtn.classList.add("hidden"); }

function stopWaves(){
  started = false;
  overlay.classList.remove("active");

  const w = waveCanvas.clientWidth;
  const h = waveCanvas.clientHeight;
  waveCtx.clearRect(0, 0, w, h);
}

audioEl.addEventListener("ended", () => {
  stopWaves();
  showPlayButton();
});

audioEl.addEventListener("pause", () => {
  stopWaves();
  showPlayButton();
});

/* =========================
   Play button dissolve (particles a bit higher)
========================= */
function dissolvePlayButton(){
  const r = playBtn.getBoundingClientRect();
  const cx = r.left + r.width / 2;
  const cy = r.top + r.height / 2 - 28;
  spawnCyanBurst(cx, cy);
  hidePlayButton();
}

/* =========================
   Waves drawing
========================= */
function strokeNeonBlue(drawPath, thickness = 1, glow = 1){
  waveCtx.save();
  waveCtx.globalCompositeOperation = "lighter";
  waveCtx.lineCap = "round";

  waveCtx.shadowColor = "rgba(90,245,255,0.08)";
  waveCtx.shadowBlur  = 11 * glow;
  waveCtx.lineWidth   = 3.4 * thickness;
  waveCtx.strokeStyle = "rgba(90,245,255,0.07)";
  drawPath(); waveCtx.stroke();

  waveCtx.shadowColor = "rgba(90,245,255,0.20)";
  waveCtx.shadowBlur  = 6.5 * glow;
  waveCtx.lineWidth   = 2.1 * thickness;
  waveCtx.strokeStyle = "rgba(90,245,255,0.18)";
  drawPath(); waveCtx.stroke();

  waveCtx.shadowBlur  = 0;
  waveCtx.lineWidth   = 1.05 * thickness;
  waveCtx.strokeStyle = "rgba(120,255,255,0.82)";
  drawPath(); waveCtx.stroke();

  waveCtx.restore();
}

function envelopeShape(u){ return Math.pow(Math.sin(Math.PI * u), 1.45); }
function fbm(u, t, s = 1){
  return (
    Math.sin((u * 10.0 * s) + t * 1.3) * 0.55 +
    Math.sin((u * 23.0 * s) - t * 2.2) * 0.28 +
    Math.sin((u * 52.0 * s) + t * 3.7) * 0.17
  );
}
function travelingPulse(u, t, speed = 0.18, width = 0.06){
  const p = (t * speed) % 1;
  const d = Math.min(Math.abs(u - p), 1 - Math.abs(u - p));
  return Math.exp(-(d * d) / (width * width));
}

function startLoop(){
  if (rafId) return;

  const loop = (now) => {
    rafId = requestAnimationFrame(loop);
    if (!started) return;

    const { level, treble } = readAudio();

    const w = waveCanvas.clientWidth;
    const h = waveCanvas.clientHeight;
    waveCtx.clearRect(0, 0, w, h);

    const t = now / 1000;
    const thickMul = waveThickness();

    const baseAmp = 6;
    const maxAmp  = 90;
    const ampPx   = baseAmp + maxAmp * Math.pow(level, 0.80);

    const electric = 0.35 + 0.95 * treble;
    const centerY = h * 0.5;

    const points = Math.max(160, Math.floor(w / 5));
    const dx = w / (points - 1);

    waveCtx.save();
    waveCtx.globalCompositeOperation = "lighter";
    waveCtx.globalAlpha = 0.07 + 0.22 * level;
    waveCtx.fillStyle = "rgba(90,245,255,0.16)";
    waveCtx.fillRect(0, centerY - 1, w, 2);
    waveCtx.restore();

    const disp = new Array(points);
    for (let i = 0; i < points; i++){
      const u = i / (points - 1);
      const idx = Math.floor(u * (timeData.length - 1));
      const a = (timeData[idx] - 128) / 128;

      const pulse1 = travelingPulse(u, t, 0.20, 0.055);
      const pulse2 = travelingPulse(u, t + 2.1, 0.14, 0.08);

      const wobble = fbm(u, t * electric, 1.0) * 0.55;
      const micro  = Math.sin(t * (12.0 * electric) + u * (140 * electric)) * 0.12;

      const env = envelopeShape(u);

      disp[i] =
        env * (
          ampPx * (a * (0.62 + 0.55 * level)) +
          (18 + 38 * level) * wobble +
          (10 + 30 * treble) * micro +
          (55 * pulse1 * (0.20 + level)) +
          (32 * pulse2 * (0.15 + level * 0.8))
        );
    }

    function lensPair(phase, alpha, thickness, glow){
      waveCtx.save();
      waveCtx.globalAlpha = alpha;

      const phaseWarp = (u) =>
        Math.sin(u * 14 + t * (1.1 + phase)) * (1.5 + 3.0 * treble);

      const upperPath = () => {
        waveCtx.beginPath();
        for (let i = 0; i < points; i++){
          const u = i / (points - 1);
          const x = i * dx;
          const y = centerY - (disp[i] + phaseWarp(u));
          if (i === 0) waveCtx.moveTo(x, y);
          else waveCtx.lineTo(x, y);
        }
      };

      const lowerPath = () => {
        waveCtx.beginPath();
        for (let i = 0; i < points; i++){
          const u = i / (points - 1);
          const x = i * dx;
          const y = centerY + (disp[i] - phaseWarp(u) * 0.6);
          if (i === 0) waveCtx.moveTo(x, y);
          else waveCtx.lineTo(x, y);
        }
      };

      const glowBoost = 0.72 + 0.85 * level + 0.55 * treble;

      strokeNeonBlue(upperPath, thickness * thickMul, glowBoost * glow);
      strokeNeonBlue(lowerPath, thickness * thickMul, glowBoost * glow);

      waveCtx.restore();
    }

    lensPair(0.0, 0.90, 1.08, 1.0);
    lensPair(1.1, 0.55, 0.95, 0.85);
    lensPair(2.2, 0.35, 0.82, 0.75);
  };

  rafId = requestAnimationFrame(loop);
}

/* =========================
   Play click (starts waves + audio)
========================= */
playBtn.addEventListener("click", async (e) => {
  e.preventDefault();
  e.stopPropagation();

  setupAnalyser();
  if (audioCtx.state === "suspended") await audioCtx.resume();

  audioEl.muted = false;
  audioEl.volume = 0.35;

  if (audioEl.paused) await audioEl.play();

  started = true;
  overlay.classList.add("active");

  dissolvePlayButton();

  scheduleLayoutUpdate();
  startLoop();
});

/* =========================
   Pause heavy work when tab hidden
========================= */
document.addEventListener("visibilitychange", () => {
  if (document.hidden){
    stopWaves();
    if (fxRaf){ cancelAnimationFrame(fxRaf); fxRaf = 0; }
  } else {
    if (!audioEl.paused) {
      started = true;
      overlay.classList.add("active");
    }
    if (particles.length) ensureFxLoop();
  }
});
</script>

<!-- CRT overlay stays as-is; your CSS controls intensity/curvature -->
<div class="crt-wrap" aria-hidden="true">
  <div class="crt"></div>
</div>

</body>
</html>












