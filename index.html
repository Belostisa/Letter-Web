<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Encrypted Letter</title>
  <link rel="stylesheet" href="style.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

  <!-- FULL BACKGROUND VIDEO -->
  <div class="bg-video">
    <video autoplay muted loop playsinline>
      <source src="media/bg.mp4" type="video/mp4">
    </video>
  </div>

  <!-- AUDIO -->
  <audio id="bgAudio" loop preload="auto" crossorigin="anonymous">
    <source src="media/sextape.mp3" type="audio/mpeg">
  </audio>

  <!-- FLOWERS -->
  <section class="flowers-section">
    <video autoplay muted loop playsinline class="flowers-video">
      <source src="media/flowers2.mp4" type="video/mp4">
    </video>
  </section>

  <!-- WAVE OVERLAY -->
  <div class="wave-overlay" id="waveOverlay" aria-hidden="true">
    <canvas id="waveCanvas"></canvas>
  </div>

  <!-- SINGLE PLAY BUTTON -->
  <button class="wave-play" id="playWave" aria-label="Play">▶</button>

  <!-- ENVELOPE -->
  <section class="envelope-section">
    <div class="envelope" onclick="openEmail()">
      <div class="envelope-back"></div>
      <div class="inbox-label">INBOX</div>
      <div class="envelope-flap"></div>
    </div>
  </section>

  <!-- EMAIL WINDOW -->
  <div class="email-overlay" id="emailOverlay">
    <div class="email-window">
      <div class="email-header">
        <span class="email-title">Inbox</span>
        <button class="email-close" onclick="closeEmail()">✕</button>
      </div>

      <div class="email-body" id="emailContent"></div>

      <div class="email-footer">
        <button onclick="prevPage()">◀ Prev</button>
        <span id="pageIndicator">1 / 3</span>
        <button onclick="nextPage()">Next ▶</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   EMAIL PAGES (unchanged)
========================= */
const pages = [
`Алла, я думаю мне очень повезло встретить тебя. Спасибо за тепло, доверие, и все моменты, что ты могла мне дать. Мне жаль, что все складывается именно так и я не смогу показать и дать тебе всего, чего ты заслуживаешь, просто за то, что ты есть.

Это время особенно важно для меня. В нём я ощутила простую, спокойную связь, в которой мне не приходилось защищаться, притворяться или объясняться. Я рада, что и ты в свою очередь могла мне открыться. Всё это помогло мне убедиться, что подобного рода чувства имеют место быть и в моей жизни.

Спасибо, что позволила мне быть рядом, насколько это возможно. Я верю, что мы обе достойны любви, в которой не нужно что-то доказывать, быть удобной. Той, где можно быть собой, а не прятаться за маски играя друг с другом в игры. Не прятаться и от себя.`,
`Я понимаю, почему последнее время ты отдалилась. Возможно, так проще справляться, потихоньку стирая всё. И пусть мне тяжело это чувствовать, я не злюсь. Но я не хочу притворяться, что это ничего не значило, вероятно не только для меня.

Я надеюсь, что однажды ты выберешь себя, без страха или чувства долга, и позволишь себе жить свободно. Что когда-нибудь ты сможешь испытать любовь не через призму тревоги и защиты. В первую очередь к себе. И быть уверенной и спокойной в этом чувстве.

Ты много носишь в себе, и я это вижу. Все вещи, что ты описывала — не просто часть тебя, а то, над чем можно и нужно работать. Они имеют свойство разрушать. А ты заслуживаешь того, чтобы тебе жилось легче, с поддержкой. Я думаю ты достаточно сильная, чтобы её принять.
`,
`Пожалуйста, не считай себя плохим человеком. Я никогда и ни за что не считала тебя таковой. Что бы ты ни думала сама, что бы ни выбиравала. Ты показывала себя чувствующей и живой, и именно поэтому ты стала мне важна. 

Я очень хочу, чтобы у тебя получилось делать то, что тебе действительно интересно. Чтобы хватало сил и желания на свои идеи. Ты усердная и способная, поэтому я даже не сомневаюсь, что так и будет.

Мне будет больно тебя отпускать, но я все равно рада, что у нас был шанс узнать друг друга и провести это время вместе. Надеюсь, когда-нибудь оно снова нас сведёт, и ты будешь счастливой и свободной.`
];

let currentPage = 0;

/* =========================
   TYPEWRITER REVEAL (UPDATED)
   ✅ Autoscroll while typing (mobile)
   ✅ Saves typed progress per page:
      - Close/open keeps what was typed
      - Prev/Next keeps what was typed
========================= */
const emailBody = document.getElementById("emailContent");
let typingTimer = 0;
let typingToken = 0;

// cache typed progress: pageIndex -> { i, text, done }
const typedCache = new Map();

// inject cursor CSS once
(function addCursorCSS(){
  if (document.getElementById("twCursorCSS")) return;
  const s = document.createElement("style");
  s.id = "twCursorCSS";
  s.textContent = `
    .tw-cursor{
      display:inline-block;
      width:0.7ch;
      margin-left:0.15ch;
      color:#9AFF7A;
      opacity:1;
      animation: twBlink 1.05s steps(1,end) infinite;
    }
    @keyframes twBlink { 0%,49%{opacity:1} 50%,100%{opacity:0} }
  `;
  document.head.appendChild(s);
})();

function stopTyping(){
  typingToken++;
  clearTimeout(typingTimer);
}

function autoScrollToCursor(){
  // Always keep newest typing visible (good for phones)
  // (No “near bottom” check; user asked for autoscroll with typing)
  emailBody.scrollTop = emailBody.scrollHeight;
}

function getDelayForChar(ch, prevCh){
  let d = 40; // base

  if (ch === " ") d = 16;
  if (ch === ",") d = 140;
  if (ch === "." || ch === "!" || ch === "?") d = 260;

  // breathing pause after paragraph break
  if (prevCh === "\n" && ch === "\n") d = 900;
  if (ch === "\n") d = 120;

  d += Math.random() * 18;
  return d;
}

function renderInstantFromCache(pageIndex){
  stopTyping();
  const cached = typedCache.get(pageIndex);

  // If we have full typed text, show it. If partial, show partial.
  const shown = cached?.text ?? "";
  emailBody.textContent = shown;
  document.getElementById("pageIndicator").textContent = `${pageIndex + 1} / ${pages.length}`;
  emailBody.scrollTop = 0;
}

function typewriterPage(pageIndex){
  stopTyping();
  const myToken = ++typingToken;

  const fullText = pages[pageIndex];
  const cached = typedCache.get(pageIndex);

  // If page finished typing before, show instantly (no restart)
  if (cached?.done){
    emailBody.textContent = fullText;
    document.getElementById("pageIndicator").textContent = `${pageIndex + 1} / ${pages.length}`;
    emailBody.scrollTop = 0;
    return;
  }

  // If partial progress exists, resume from there
  let i = cached?.i ?? 0;
  let typedText = cached?.text ?? "";

  emailBody.textContent = typedText;

  // cursor
  const cursor = document.createElement("span");
  cursor.className = "tw-cursor";
  cursor.textContent = "▋";
  emailBody.appendChild(cursor);

  document.getElementById("pageIndicator").textContent = `${pageIndex + 1} / ${pages.length}`;

  // start at top when opening a page
  emailBody.scrollTop = 0;

  let last = (typedText.length ? typedText[typedText.length - 1] : "");

  const step = () => {
    if (myToken !== typingToken) return;

    if (i >= fullText.length){
      // done → cache full
      typedCache.set(pageIndex, { i: fullText.length, text: fullText, done: true });
      typingTimer = setTimeout(() => {
        if (cursor.parentNode) cursor.remove();
        autoScrollToCursor();
      }, 250);
      return;
    }

    // type 1–2 chars per tick
    const burst = Math.random() < 0.15 ? 2 : 1;
    let chunk = "";

    for (let k = 0; k < burst && i < fullText.length; k++){
      const ch = fullText[i];
      cursor.insertAdjacentText("beforebegin", ch);
      chunk += ch;
      last = ch;
      i++;
    }

    typedText += chunk;
    typedCache.set(pageIndex, { i, text: typedText, done: false });

    // ✅ autoscroll during typing
    autoScrollToCursor();

    const nextCh = fullText[i] || "";
    const delay = getDelayForChar(nextCh, last);
    typingTimer = setTimeout(step, delay);
  };

  step();
}

function openEmail(){
  const env = document.querySelector(".envelope");
  const overlayEl = document.getElementById("emailOverlay");

  // start flap animation
  env.classList.add("open");

  // wait for the flap transition to finish (your CSS is 0.9s)
  const DURATION_MS = 900;

  // prevent double triggers
  if (openEmail._pending) return;
  openEmail._pending = true;

  setTimeout(() => {
    openEmail._pending = false;

    overlayEl.style.display = "flex";
    renderPage(); // typewriter + cache + autoscroll
  }, DURATION_MS + 60); // small buffer
}

function closeEmail(){
  // ✅ stop typing but DO NOT clear cache
  stopTyping();
  document.querySelector(".envelope").classList.remove("open");
  document.getElementById("emailOverlay").style.display = "none";
}

function renderPage(){
  typewriterPage(currentPage);
}

function nextPage(){
  if (currentPage < pages.length - 1){
    currentPage++;
    renderPage();
  }
}

function prevPage(){
  if (currentPage > 0){
    currentPage--;
    renderPage();
  }
}

/* =========================
   WAVES + PARTICLES
   (UNCHANGED BELOW THIS LINE)
========================= */
const playBtn = document.getElementById("playWave");
const audioEl = document.getElementById("bgAudio");
const overlay = document.getElementById("waveOverlay");
const waveCanvas  = document.getElementById("waveCanvas");
const waveCtx     = waveCanvas.getContext("2d", { alpha: true });

const flowersSection = document.querySelector(".flowers-section");
const flowersVideo   = document.querySelector(".flowers-video"); // ✅ for tighter hit area
const envelopeEl     = document.querySelector(".envelope");

let audioCtx = null;
let analyser = null;
let srcNode  = null;
let timeData = null;
let freqData = null;

let started = false;
let rafId = 0;
let posRaf = 0;

const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
const lerp  = (a, b, t) => a + (b - a) * t;

function waveThickness(){
  return window.matchMedia("(max-width: 600px)").matches ? 1.0 : 1.25;
}

/* =========================
   FULLSCREEN FX CANVAS
========================= */
const fxCanvas = document.createElement("canvas");
fxCanvas.id = "fxCanvas";
Object.assign(fxCanvas.style, {
  position: "fixed",
  inset: "0",
  width: "100vw",
  height: "100vh",
  zIndex: "5",
  pointerEvents: "none"
});
document.body.appendChild(fxCanvas);

const fxCtx = fxCanvas.getContext("2d", { alpha: true });

function resizeFxCanvas(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  fxCanvas.width = Math.floor(innerWidth * dpr);
  fxCanvas.height = Math.floor(innerHeight * dpr);
  fxCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function resizeWaveCanvas(){
  const rect = waveCanvas.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const w = Math.max(1, Math.floor(rect.width  * dpr));
  const h = Math.max(1, Math.floor(rect.height * dpr));
  if (waveCanvas.width !== w || waveCanvas.height !== h){
    waveCanvas.width = w;
    waveCanvas.height = h;
  }
  waveCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

/* =========================
   Place waves BETWEEN flowers + envelope
========================= */
function updateWavePosition(){
  if (!flowersSection || !envelopeEl) return;

  const f = flowersSection.getBoundingClientRect();
  const e = envelopeEl.getBoundingClientRect();

  let y = (f.bottom + e.top) / 2;
  y -= Math.min(28, innerHeight * 0.035);

  const overlayH = overlay?.getBoundingClientRect().height || 120;
  y -= overlayH / 2;

  const pad = Math.max(48, Math.min(96, innerHeight * 0.08));
  y = clamp(y, pad, innerHeight - pad);

  document.documentElement.style.setProperty("--wave-y", `${y}px`);
}

function scheduleLayoutUpdate(){
  if (posRaf) return;
  posRaf = requestAnimationFrame(() => {
    posRaf = 0;
    updateWavePosition();
    resizeWaveCanvas();
    resizeFxCanvas();
  });
}

window.addEventListener("resize", scheduleLayoutUpdate, { passive: true });
window.addEventListener("scroll", scheduleLayoutUpdate, { passive: true });

if (window.visualViewport){
  visualViewport.addEventListener("resize", scheduleLayoutUpdate, { passive: true });
  visualViewport.addEventListener("scroll", scheduleLayoutUpdate, { passive: true });
}

const ro = new ResizeObserver(() => scheduleLayoutUpdate());
if (flowersSection) ro.observe(flowersSection);
if (envelopeEl) ro.observe(envelopeEl);

scheduleLayoutUpdate();
setTimeout(scheduleLayoutUpdate, 150);
setTimeout(scheduleLayoutUpdate, 650);

/* =========================
   Audio analyser
========================= */
function setupAnalyser(){
  if (audioCtx) return;

  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  analyser.smoothingTimeConstant = 0.82;

  timeData = new Uint8Array(analyser.frequencyBinCount);
  freqData = new Uint8Array(analyser.frequencyBinCount);

  srcNode = audioCtx.createMediaElementSource(audioEl);
  srcNode.connect(analyser);
  analyser.connect(audioCtx.destination);
}

let rmsSmooth = 0;
let trebleSmooth = 0;

function readAudio(){
  analyser.getByteTimeDomainData(timeData);
  analyser.getByteFrequencyData(freqData);

  let sum = 0;
  for (let i = 0; i < timeData.length; i++){
    const v = (timeData[i] - 128) / 128;
    sum += v * v;
  }
  const rms = Math.sqrt(sum / timeData.length);
  rmsSmooth = lerp(rmsSmooth, rms, 0.09);

  let hi = 0;
  const start = Math.floor(freqData.length * 0.35);
  for (let i = start; i < freqData.length; i++) hi += freqData[i];
  const hiNorm = hi / ((freqData.length - start) * 255);
  trebleSmooth = lerp(trebleSmooth, clamp(hiNorm, 0, 1), 0.12);

  return { level: rmsSmooth, treble: trebleSmooth };
}

/* =========================
   Particles
========================= */
const particles = [];
function rand(a, b){ return a + Math.random() * (b - a); }

function spawnFlowerOrbs(vx, vy){
  const count = 18;
  for (let i = 0; i < count; i++){
    const angle = rand(-Math.PI * 0.80, -Math.PI * 0.20);
    const speed = rand(0.9, 2.6);

    particles.push({
      x: vx, y: vy,
      vx: Math.cos(angle) * speed + rand(-0.25, 0.25),
      vy: Math.sin(angle) * speed + rand(-0.18, 0.12),
      life: 1,
      r: rand(0.9, 1.8),
      w: rand(1.4, 2.8),
      ph: rand(0, Math.PI * 2),
      type: "orb"
    });
  }
}

function spawnCyanBurst(vx, vy){
  for (let i = 0; i < 14; i++){
    const angle = rand(0, Math.PI * 2);
    const speed = rand(0.7, 2.0);
    particles.push({
      x: vx, y: vy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      r: rand(1.8, 3.4),
      type: "cyan"
    });
  }
}

function drawParticles(){
  fxCtx.clearRect(0, 0, innerWidth, innerHeight);

  for (let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];

    p.x += p.vx;
    p.y += p.vy;

    p.vx *= 0.989;
    p.vy *= 0.988;
    p.vy -= (p.type === "orb" ? 0.0062 : 0.0028);

    if (p.type === "orb"){
      const t = performance.now() * 0.001;
      p.x += Math.sin(t * p.w + p.ph) * 0.28;
    }

    p.life -= (p.type === "orb" ? 0.009 : 0.014);

    if (p.life <= 0){
      particles.splice(i, 1);
      continue;
    }

    fxCtx.save();
    fxCtx.globalCompositeOperation = "lighter";
    fxCtx.globalAlpha = p.life;

    if (p.type === "cyan"){
      fxCtx.fillStyle = "rgba(120,255,255,0.66)";
      fxCtx.shadowColor = "rgba(120,255,255,0.30)";
      fxCtx.shadowBlur = 10;

      fxCtx.beginPath();
      fxCtx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      fxCtx.fill();
      fxCtx.restore();
      continue;
    }

    const core = p.r;
    const aura = p.r * 6.5;

    fxCtx.fillStyle = "rgba(255,140,210,0.10)";
    fxCtx.shadowColor = "rgba(255,140,210,0.22)";
    fxCtx.shadowBlur = 18;
    fxCtx.beginPath();
    fxCtx.arc(p.x, p.y, aura, 0, Math.PI * 2);
    fxCtx.fill();

    fxCtx.shadowBlur = 12;
    fxCtx.fillStyle = "rgba(255,195,235,0.42)";
    fxCtx.beginPath();
    fxCtx.arc(p.x, p.y, core, 0, Math.PI * 2);
    fxCtx.fill();

    fxCtx.restore();
  }
}

/* =========================
   FLOWER CLICK -> ORBS (even smaller area)
========================= */
let lastFlower = 0;

function pointInShrunkRect(x, y, r, shrinkX = 0.18, shrinkTop = 0.10, shrinkBottom = 0.22){
  const left   = r.left + r.width  * shrinkX;
  const right  = r.right - r.width * shrinkX;
  const top    = r.top + r.height  * shrinkTop;
  const bottom = r.bottom - r.height * shrinkBottom;
  return (x >= left && x <= right && y >= top && y <= bottom);
}

document.addEventListener("click", (e) => {
  if (!flowersVideo) return;
  if (e.target.closest(".envelope") || e.target.closest(".email-overlay")) return;

  const r = flowersVideo.getBoundingClientRect();
  const inside = pointInShrunkRect(e.clientX, e.clientY, r, 0.28, 0.16, 0.44);
  if (!inside) return;

  const now = Date.now();
  if (now - lastFlower < 140) return;
  lastFlower = now;

  spawnFlowerOrbs(e.clientX, e.clientY);
}, { passive: true });

/* =========================
   Play button dissolve (unchanged)
========================= */
function dissolvePlayButton(){
  const r = playBtn.getBoundingClientRect();
  const cx = r.left + r.width / 2;
  const cy = r.top + r.height / 2;
  spawnCyanBurst(cx, cy);
  playBtn.classList.add("hidden");
}

/* =========================
   Waves drawing (unchanged)
========================= */
function strokeNeonBlue(drawPath, thickness = 1, glow = 1){
  waveCtx.save();
  waveCtx.globalCompositeOperation = "lighter";
  waveCtx.lineCap = "round";

  waveCtx.shadowColor = "rgba(90,245,255,0.08)";
  waveCtx.shadowBlur  = 11 * glow;
  waveCtx.lineWidth   = 3.4 * thickness;
  waveCtx.strokeStyle = "rgba(90,245,255,0.07)";
  drawPath(); waveCtx.stroke();

  waveCtx.shadowColor = "rgba(90,245,255,0.20)";
  waveCtx.shadowBlur  = 6.5 * glow;
  waveCtx.lineWidth   = 2.1 * thickness;
  waveCtx.strokeStyle = "rgba(90,245,255,0.18)";
  drawPath(); waveCtx.stroke();

  waveCtx.shadowBlur  = 0;
  waveCtx.lineWidth   = 1.05 * thickness;
  waveCtx.strokeStyle = "rgba(120,255,255,0.82)";
  drawPath(); waveCtx.stroke();

  waveCtx.restore();
}

function envelopeShape(u){ return Math.pow(Math.sin(Math.PI * u), 1.45); }
function fbm(u, t, s = 1){
  return (
    Math.sin((u * 10.0 * s) + t * 1.3) * 0.55 +
    Math.sin((u * 23.0 * s) - t * 2.2) * 0.28 +
    Math.sin((u * 52.0 * s) + t * 3.7) * 0.17
  );
}
function travelingPulse(u, t, speed = 0.18, width = 0.06){
  const p = (t * speed) % 1;
  const d = Math.min(Math.abs(u - p), 1 - Math.abs(u - p));
  return Math.exp(-(d * d) / (width * width));
}

function startLoop(){
  if (rafId) return;

  const loop = (now) => {
    rafId = requestAnimationFrame(loop);
    if (!started) return;

    const { level, treble } = readAudio();

    const w = waveCanvas.clientWidth;
    const h = waveCanvas.clientHeight;
    waveCtx.clearRect(0, 0, w, h);

    const t = now / 1000;
    const thickMul = waveThickness();

    const baseAmp = 6;
    const maxAmp  = 90;
    const ampPx   = baseAmp + maxAmp * Math.pow(level, 0.80);

    const electric = 0.35 + 0.95 * treble;
    const centerY = h * 0.5;

    const points = Math.max(240, Math.floor(w / 3));
    const dx = w / (points - 1);

    waveCtx.save();
    waveCtx.globalCompositeOperation = "lighter";
    waveCtx.globalAlpha = 0.07 + 0.22 * level;
    waveCtx.fillStyle = "rgba(90,245,255,0.16)";
    waveCtx.fillRect(0, centerY - 1, w, 2);
    waveCtx.restore();

    const disp = new Array(points);
    for (let i = 0; i < points; i++){
      const u = i / (points - 1);
      const idx = Math.floor(u * (timeData.length - 1));
      const a = (timeData[idx] - 128) / 128;

      const pulse1 = travelingPulse(u, t, 0.20, 0.055);
      const pulse2 = travelingPulse(u, t + 2.1, 0.14, 0.08);

      const wobble = fbm(u, t * electric, 1.0) * 0.55;
      const micro  = Math.sin(t * (12.0 * electric) + u * (140 * electric)) * 0.12;

      const env = envelopeShape(u);

      disp[i] =
        env * (
          ampPx * (a * (0.62 + 0.55 * level)) +
          (18 + 38 * level) * wobble +
          (10 + 30 * treble) * micro +
          (55 * pulse1 * (0.20 + level)) +
          (32 * pulse2 * (0.15 + level * 0.8))
        );
    }

    function lensPair(phase, alpha, thickness, glow){
      waveCtx.save();
      waveCtx.globalAlpha = alpha;

      const phaseWarp = (u) =>
        Math.sin(u * 14 + t * (1.1 + phase)) * (1.5 + 3.0 * treble);

      const upperPath = () => {
        waveCtx.beginPath();
        for (let i = 0; i < points; i++){
          const u = i / (points - 1);
          const x = i * dx;
          const y = centerY - (disp[i] + phaseWarp(u));
          if (i === 0) waveCtx.moveTo(x, y);
          else waveCtx.lineTo(x, y);
        }
      };

      const lowerPath = () => {
        waveCtx.beginPath();
        for (let i = 0; i < points; i++){
          const u = i / (points - 1);
          const x = i * dx;
          const y = centerY + (disp[i] - phaseWarp(u) * 0.6);
          if (i === 0) waveCtx.moveTo(x, y);
          else waveCtx.lineTo(x, y);
        }
      };

      const glowBoost = 0.72 + 0.85 * level + 0.55 * treble;

      strokeNeonBlue(upperPath, thickness * thickMul, glowBoost * glow);
      strokeNeonBlue(lowerPath, thickness * thickMul, glowBoost * glow);

      waveCtx.restore();
    }

    lensPair(0.0, 0.90, 1.08, 1.0);
    lensPair(1.1, 0.55, 0.95, 0.85);
    lensPair(2.2, 0.35, 0.82, 0.75);
  };

  rafId = requestAnimationFrame(loop);
}

/* =========================
   FX render loop (runs ALWAYS, even before play)
========================= */
let fxRaf = 0;
function startFxLoop(){
  if (fxRaf) return;
  const tick = () => {
    fxRaf = requestAnimationFrame(tick);
    drawParticles();
  };
  fxRaf = requestAnimationFrame(tick);
}
startFxLoop();

/* =========================
   Play click (starts waves + audio) (unchanged)
========================= */
playBtn.addEventListener("click", async (e) => {
  e.preventDefault();
  e.stopPropagation();

  setupAnalyser();
  if (audioCtx.state === "suspended") await audioCtx.resume();

  audioEl.muted = false;
  audioEl.volume = 0.35;

  if (audioEl.paused) await audioEl.play();

  started = true;
  overlay.classList.add("active");

  dissolvePlayButton();

  scheduleLayoutUpdate();
  startLoop();
});
</script>

</body>
</html>












